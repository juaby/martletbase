use bytes::{Buf, BufMut, Bytes, BytesMut};
use rand::Rng;

use crate::protocol::{DatabasePacket, PacketPayload};
use crate::protocol::mysql::constant::{CHARSET, MySQLAuthenticationMethod, MySQLCapabilityFlag, MySQLStatusFlag, NUL, PROTOCOL_VERSION, SEED, SERVER_VERSION};
use crate::session::mysql::SessionContext;

pub mod text;
pub mod binary;

const PAYLOAD_LENGTH: u32 = 3;
const SEQUENCE_LENGTH: u32 = 1;

/// Generate random bytes.
///
/// @param length length for generated bytes.
/// @return generated bytes
///
pub fn generate_random_bytes(len: u32, seed: &mut Vec<u8>) -> Vec<u8> {
    let mut random = rand::thread_rng();
    for _i in 0..len {
        seed.push(SEED[random.gen_range(0..SEED.len())]);
    }
    seed.to_vec()
}

pub struct MySQLPacketHeader {
    len: u64,
    sequence_id: u32,
    command_packet_type: u8,
    session_id: u64,
}

impl MySQLPacketHeader {
    pub fn new(len: u64, sequence_id: u32, command_packet_type: u8, session_id: u64) -> Self {
        MySQLPacketHeader {
            len,
            sequence_id,
            command_packet_type,
            session_id,
        }
    }

    pub fn get_len(&self) -> u64 {
        self.len
    }

    pub fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }

    pub fn get_command_packet_type(&self) -> u8 {
        self.command_packet_type
    }

    pub fn get_session_id(&self) -> u64 {
        self.session_id
    }
}

/**
 * MySQL payload operation for MySQL packet data types.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/describing-packets.html">describing packets</a>
 */

pub struct MySQLPacketPayload {
    bytes_mut: BytesMut,
}

impl MySQLPacketPayload {
    pub fn new() -> Self {
        MySQLPacketPayload {
            bytes_mut: BytesMut::new()
        }
    }

    pub fn new_with_payload(bytes_mut: BytesMut) -> Self {
        MySQLPacketPayload {
            bytes_mut: bytes_mut
        }
    }

    pub fn put_u8(&mut self, val: u8) {
        self.bytes_mut.put_u8(val);
    }

    pub fn put_u16_le(&mut self, val: u16) {
        self.bytes_mut.put_u16_le(val);
    }

    pub fn put_u32_le(&mut self, val: u32) {
        self.bytes_mut.put_u32_le(val);
    }

    pub fn put_i32_le(&mut self, val: i32) {
        self.bytes_mut.put_i32_le(val);
    }

    pub fn put_u64_le(&mut self, val: u64) {
        self.bytes_mut.put_u64_le(val);
    }

    pub fn put_i64_le(&mut self, val: i64) {
        self.bytes_mut.put_i64_le(val);
    }

    pub fn put_f32_le(&mut self, val: f32) {
        self.bytes_mut.put_f32_le(val);
    }

    pub fn put_f64_le(&mut self, val: f64) {
        self.bytes_mut.put_f64_le(val);
    }

    pub fn put_slice(&mut self, val: &[u8]) {
        self.bytes_mut.put_slice(val);
    }

    pub fn put_string_with_nul(&mut self, val: &[u8]) {
        self.bytes_mut.put_slice(val);
        self.bytes_mut.put_u8(NUL);
    }

    pub fn get_uint_le(&mut self, n: usize) -> u64 {
        self.bytes_mut.get_uint_le(n)
    }

    pub fn get_int_le(&mut self, n: usize) -> i64 {
        self.bytes_mut.get_int_le(n)
    }

    pub fn get_f32_le(&mut self) -> f32 {
        self.bytes_mut.get_f32_le()
    }

    pub fn get_f64_le(&mut self) -> f64 {
        self.bytes_mut.get_f64_le()
    }

    pub fn get_uint(&mut self, n: usize) -> u64 {
        self.bytes_mut.get_uint(n)
    }

    pub fn get_int(&mut self, n: usize) -> i64 {
        self.bytes_mut.get_int(n)
    }

    pub fn advance(&mut self, n: usize) {
        self.bytes_mut.advance(n);
    }

    // string with nul
    pub fn get_string_nul(&mut self) -> String {
        let pos = match self.bytes_mut.to_vec().iter().position(|&x| x == 0) {
            Some(pos) => pos,
            None => 0 // TODO
        };
        if pos == 0 {
            "".to_string()
        } else {
            let bytes = self.bytes_mut.split_to(pos);
            let result = String::from_utf8_lossy(bytes.to_vec().as_slice()).to_string();
            self.bytes_mut.advance(1);
            result
        }
    }

    /**
     * Write lenenc integer to byte buffers.
     *
     * @see <a href="https://dev.mysql.com/doc/internals/en/integer.html#packet-Protocol::LengthEncodedInteger">LengthEncodedInteger</a>
     *
     * @param value lenenc integer
     */
    pub fn put_int_lenenc(&mut self, v: usize) {
        if v < 0xfb {
            self.bytes_mut.put_u8(v as u8);
        } else if v < 0x10000 {
            self.bytes_mut.put_u8(0xfc);
            self.bytes_mut.put_u16_le(v as u16);
        } else if v < 0x1000000 {
            self.bytes_mut.put_u8(0xfd);
            self.bytes_mut.put_uint_le(v as u64, 3);
        } else {
            self.bytes_mut.put_u8(0xfe);
            self.bytes_mut.put_u64_le(v as u64);
        }
    }

    /**
     * Read lenenc integer from byte buffers.
     *
     * @see <a href="https://dev.mysql.com/doc/internals/en/integer.html#packet-Protocol::LengthEncodedInteger">LengthEncodedInteger</a>
     *
     * @return lenenc integer
     */
    pub fn get_int_lenenc(&mut self) -> u64 {
        let first_byte = self.bytes_mut.get_uint(1) & 0xff;
        if first_byte < 0xfb {
            first_byte
        } else if 0xfb == first_byte {
            0
        } else if 0xfc == first_byte {
            self.bytes_mut.get_uint_le(2)
        } else if 0xfd == first_byte {
            self.bytes_mut.get_uint_le(3)
        } else {
            self.bytes_mut.get_uint_le(8)
        }
    }

    /**
     * Write lenenc string to byte buffers.
     *
     * @see <a href="https://dev.mysql.com/doc/internals/en/string.html#packet-Protocol::FixedLengthString">FixedLengthString</a>
     *
     * @param value fixed length string
     */
    pub fn put_string_lenenc(&mut self, v: &[u8]) {
        let len = v.len();
        if len == 0 {
            self.put_u8(0);
        } else {
            self.put_int_lenenc(len);
            self.put_slice(v);
        }
    }

    /**
     * Read lenenc string from byte buffers for bytes.
     *
     * @see <a href="https://dev.mysql.com/doc/internals/en/string.html#packet-Protocol::FixedLengthString">FixedLengthString</a>
     *
     * @return lenenc bytes
     */
    pub fn get_string_lenenc(&mut self) -> Vec<u8> {
        let length = self.get_int_lenenc() as u32;
        self.bytes_mut.split_to(length as usize).to_vec()
    }

    /**
    * Read fixed length string from byte buffers and return bytes.
    *
    * @see <a href="https://dev.mysql.com/doc/internals/en/string.html#packet-Protocol::FixedLengthString">FixedLengthString</a>
    *
    * @param length length of fixed string
    *
    * @return fixed length bytes
    */
    pub fn get_string_fix(&mut self) -> Vec<u8> {
        let length = self.bytes_mut.get_uint(1) as u32 & 0xff;
        self.bytes_mut.split_to(length as usize).to_vec()
    }

    /**
    * Read fixed length string from byte buffers and return bytes.
    *
    * @see <a href="https://dev.mysql.com/doc/internals/en/string.html#packet-Protocol::FixedLengthString">FixedLengthString</a>
    *
    * @param length length of fixed string
    *
    * @return fixed length bytes
    */
    pub fn get_string_fix_length(&mut self, length: u32) -> Vec<u8> {
        self.bytes_mut.split_to(length as usize).to_vec()
    }

    /**
     * Read rest of packet string from byte buffers and return bytes.
     *
     * @see <a href="https://dev.mysql.com/doc/internals/en/string.html#packet-Protocol::RestOfPacketString">RestOfPacketString</a>
     *
     * @return rest of packet string bytes
     */
    pub fn get_remaining_bytes(&mut self) -> Vec<u8> {
        self.bytes_mut.to_vec()
    }
}

impl PacketPayload for MySQLPacketPayload {
    fn get_payload(&mut self) -> Bytes {
        self.bytes_mut.copy_to_bytes(self.bytes_mut.len())
    }
}

pub trait MySQLPacket {
    /**
     * Get sequence ID.
     *
     * @return sequence ID
     */
    fn get_sequence_id(&self) -> u32;
}

/**
 * Handshake packet protocol for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake">Handshake</a>
 */
pub struct MySQLHandshakePacket {
    protocol_version: u8,
    server_version: String,
    thread_id: u32,
    capability_flags: MySQLCapabilityFlag,
    character_set: u8,
    status_flag: u32,
    seed1: Vec<u8>,
    seed2: Vec<u8>,
    auth_plugin_name: String,
}

impl MySQLHandshakePacket {
    pub fn new(thread_id: u32, seed1: Vec<u8>, seed2: Vec<u8>) -> Self {
        let mut capability_flags: MySQLCapabilityFlag = MySQLCapabilityFlag::empty(); // capability_flags_lower
        capability_flags |= MySQLCapabilityFlag::CLIENT_LONG_PASSWORD;
        capability_flags |= MySQLCapabilityFlag::CLIENT_FOUND_ROWS;
        capability_flags |= MySQLCapabilityFlag::CLIENT_LONG_FLAG;
        capability_flags |= MySQLCapabilityFlag::CLIENT_CONNECT_WITH_DB;
        capability_flags |= MySQLCapabilityFlag::CLIENT_ODBC;
        capability_flags |= MySQLCapabilityFlag::CLIENT_IGNORE_SPACE;
        capability_flags |= MySQLCapabilityFlag::CLIENT_PROTOCOL_41;
        capability_flags |= MySQLCapabilityFlag::CLIENT_INTERACTIVE;
        capability_flags |= MySQLCapabilityFlag::CLIENT_IGNORE_SIGPIPE;
        capability_flags |= MySQLCapabilityFlag::CLIENT_TRANSACTIONS;
        capability_flags |= MySQLCapabilityFlag::CLIENT_SECURE_CONNECTION;

        capability_flags |= MySQLCapabilityFlag::CLIENT_PLUGIN_AUTH;

        MySQLHandshakePacket {
            protocol_version: PROTOCOL_VERSION,
            server_version: SERVER_VERSION.to_string(),
            thread_id: thread_id,
            capability_flags: capability_flags,
            character_set: CHARSET,
            status_flag: MySQLStatusFlag::ServerStatusAutocommit as u32,
            seed1: seed1,
            seed2: seed2,
            auth_plugin_name: MySQLAuthenticationMethod::SecurePasswordAuthentication.value().to_string(),
        }
    }
}

impl MySQLPacket for MySQLHandshakePacket {
    fn get_sequence_id(&self) -> u32 {
        0
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLHandshakePacket {
    fn encode<'p, 'd>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(this.protocol_version); // protocol version
        payload.put_string_with_nul(this.server_version.as_bytes()); // server version
        payload.put_u32_le(this.thread_id); //thread id
        payload.put_string_with_nul(this.seed1.as_slice()); //seed 1
        payload.put_u16_le((this.capability_flags.bits() & 0xFFFF) as u16); // capability_flags_lower
        payload.put_u8(this.character_set); // charset
        payload.put_u16_le(this.status_flag as u16); // server status
        payload.put_u16_le((this.capability_flags.bits() >> 16) as u16); // capability_flags_upper
        // isClientPluginAuth
        // seed len
        if this.capability_flags.contains(MySQLCapabilityFlag::CLIENT_PLUGIN_AUTH) {
            payload.put_u8((this.seed1.len() + this.seed2.len() + 1) as u8);
        } else {
            payload.put_u8(0);
        }
        // Write null for reserved to byte buffers.
        let reserved: [u8; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        payload.put_slice(&reserved);
        // isClientSecureConnection
        // seed 2
        if this.capability_flags.contains(MySQLCapabilityFlag::CLIENT_SECURE_CONNECTION) {
            payload.put_string_with_nul(this.seed2.as_slice());
        }
        // isClientPluginAuth
        // auth_plugin_name
        if this.capability_flags.contains(MySQLCapabilityFlag::CLIENT_PLUGIN_AUTH) {
            payload.put_string_with_nul(this.auth_plugin_name.as_bytes());
        }

        payload
    }
}

/**
 * MySQL auth switch request packet.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchRequest">AuthSwitchRequest</a>
 */
pub struct MySQLAuthSwitchRequestPacket {
    sequence_id: u32,
    auth_plugin_name: String,
    seed1: Vec<u8>,
    seed2: Vec<u8>,
}

impl MySQLAuthSwitchRequestPacket {
    pub fn new(sequence_id: u32, seed1: Vec<u8>, seed2: Vec<u8>) -> Self {
        MySQLAuthSwitchRequestPacket {
            sequence_id: sequence_id,
            seed1: seed1,
            seed2: seed2,
            auth_plugin_name: MySQLAuthenticationMethod::SecurePasswordAuthentication.value().to_string(),
        }
    }
}

impl MySQLPacket for MySQLAuthSwitchRequestPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLAuthSwitchRequestPacket {
    fn encode<'p, 'd>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(0xfe);
        payload.put_string_with_nul(this.auth_plugin_name.as_bytes());
        payload.put_slice(this.seed1.as_slice());
        payload.put_string_with_nul(this.seed2.as_slice());
        payload
    }
}

/**
 * Handshake response above MySQL 4.1 packet protocol.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse41">HandshakeResponse41</a>
 */
pub struct MySQLHandshakeResponse41Packet {
    sequence_id: u32,
    max_packet_size: u32,
    character_set: u8,
    user_name: String,
    auth_response: Vec<u8>,
    capability_flags: MySQLCapabilityFlag,
    database: String,
    auth_plugin_name: String,
}

impl MySQLHandshakeResponse41Packet {
    pub fn new() -> Self {
        MySQLHandshakeResponse41Packet {
            sequence_id: 0,
            max_packet_size: 0,
            character_set: 0,
            user_name: "".to_string(),
            auth_response: vec![],
            capability_flags: MySQLCapabilityFlag::empty(),
            database: "".to_string(),
            auth_plugin_name: "".to_string(),
        }
    }

    pub fn get_user_name(&self) -> String {
        self.user_name.clone()
    }

    pub fn get_auth_response(&self) -> Vec<u8> {
        self.auth_response.clone()
    }

    pub fn get_database(&self) -> String {
        self.database.clone()
    }

    pub fn get_capability_flags(&self) -> MySQLCapabilityFlag {
        self.capability_flags
    }

    pub fn get_auth_plugin_name(&self) -> String {
        self.auth_plugin_name.clone()
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLHandshakeResponse41Packet {
    fn decode<'p, 'd>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload, session_ctx: &mut SessionContext) -> &'d mut Self {
        this.sequence_id = header.sequence_id;
        this.capability_flags = MySQLCapabilityFlag::from_bits(payload.get_uint_le(4) as u32).unwrap();
        this.max_packet_size = payload.get_uint_le(4) as u32;
        this.character_set = (payload.get_uint(1) & 0xff) as u8;
        payload.advance(23);

        // string with nul
        this.user_name = payload.get_string_nul();

        this.auth_response = if this.capability_flags.contains(MySQLCapabilityFlag::CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) {
            payload.get_string_lenenc()
        } else if this.capability_flags.contains(MySQLCapabilityFlag::CLIENT_SECURE_CONNECTION) {
            payload.get_string_fix()
        } else {
            let auth = payload.get_string_nul();
            auth.into_bytes()
        };

        this.database = if this.capability_flags.contains(MySQLCapabilityFlag::CLIENT_CONNECT_WITH_DB) {
            payload.get_string_nul()
        } else {
            String::from("")
        };

        this.auth_plugin_name = if this.capability_flags.contains(MySQLCapabilityFlag::CLIENT_PLUGIN_AUTH) {
            payload.get_string_nul()
        } else {
            String::from("")
        };
        this
    }
}

impl MySQLPacket for MySQLHandshakeResponse41Packet {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * MySQL auth switch request packet.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchResponse">AuthSwitchResponse</a>
 */
pub struct MySQLAuthSwitchResponsePacket {
    sequence_id: u32,
    auth_response: Vec<u8>,
}

impl MySQLAuthSwitchResponsePacket {
    pub fn new() -> Self {
        MySQLAuthSwitchResponsePacket {
            sequence_id: 0,
            auth_response: vec![],
        }
    }

    pub fn get_auth_response(&self) -> Vec<u8> {
        self.auth_response.clone()
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLAuthSwitchResponsePacket {
    fn decode<'p, 'd>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload, session_ctx: &mut SessionContext) -> &'d mut Self {
        this.sequence_id = header.sequence_id;
        this.auth_response = payload.get_remaining_bytes();
        this
    }
}

impl MySQLPacket for MySQLAuthSwitchResponsePacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
* EOF packet protocol for MySQL.
*
* @see <a href="https://dev.mysql.com/doc/internals/en/packet-EOF_Packet.html">EOF Packet</a>
*/
pub struct MySQLEOFPacket {
    /**
     * Header of EOF packet.
     * 0xfe;
     */
    /// 0xfe;
    header: u8,
    sequence_id: u32,
    warnings: u16,
    status_flags: u16,
}

impl MySQLEOFPacket {
    pub fn new(sequence_id: u32) -> Self {
        MySQLEOFPacket {
            header: 0xfe,
            sequence_id,
            warnings: 0,
            status_flags: MySQLStatusFlag::ServerStatusAutocommit as u16,
        }
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLEOFPacket {
    fn encode<'p, 'd>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(this.header);
        payload.put_u16_le(this.warnings);
        payload.put_u16_le(this.status_flags);

        payload
    }
}

impl MySQLPacket for MySQLEOFPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * OK packet protocol for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html">OK Packet</a>
 */
pub struct MySQLOKPacket {
    /**
     * Header of OK packet.
     */
    header: u8,
    sequence_id: u32,
    affected_rows: u64,
    last_insert_id: u64,
    status_flag: u32,
    warnings: u32,
    info: String,
}

impl MySQLOKPacket {
    pub fn new(sequence_id: u32, affected_rows: u64, last_insert_id: u64) -> Self {
        MySQLOKPacket {
            header: 0x00,
            sequence_id: sequence_id,
            affected_rows: affected_rows,
            last_insert_id: last_insert_id,
            status_flag: MySQLStatusFlag::ServerStatusAutocommit as u32,
            warnings: 0,
            info: "".to_string(),
        }
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLOKPacket {
    fn encode<'p, 'd>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(this.header);

        payload.put_int_lenenc(this.affected_rows as usize);
        payload.put_int_lenenc(this.last_insert_id as usize);

        payload.put_u16_le(this.status_flag as u16);
        payload.put_u16_le(this.warnings as u16);

        payload.put_slice(this.info.as_bytes());

        payload
    }
}

impl MySQLPacket for MySQLOKPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * ERR packet protocol for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/packet-ERR_Packet.html">ERR Packet</a>
 */
pub struct MySQLErrPacket {
    /**
     * Header of ERR packet.
     */
    /// 0xff;
    header: u8,
    /// "#";
    sql_state_marker: String,
    sequence_id: u32,
    error_code: u32,
    sql_state: String,
    error_message: String,
}

impl MySQLErrPacket {
    pub fn new(sequence_id: u32, error_code: u32, sql_state: String, error_message: String) -> Self {
        MySQLErrPacket {
            header: 0xff,
            sql_state_marker: "#".to_string(),
            sequence_id,
            error_code: 0,
            sql_state: sql_state,
            error_message: error_message,
        }
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLErrPacket {
    fn encode<'p, 'd>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(this.header);

        payload.put_u16_le(this.error_code as u16);
        payload.put_slice(this.sql_state_marker.as_bytes());
        payload.put_slice(this.sql_state.as_bytes());
        payload.put_slice(this.error_message.as_bytes());

        payload
    }
}

impl MySQLPacket for MySQLErrPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * COM_QUERY response field count packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-query-response.html">COM_QUERY field count</a>
 */
pub struct MySQLFieldCountPacket {
    sequence_id: u32,
    column_count: u32,
}

impl MySQLFieldCountPacket {
    pub fn new(sequence_id: u32, column_count: u32) -> Self {
        MySQLFieldCountPacket {
            sequence_id,
            column_count,
        }
    }
}

impl MySQLPacket for MySQLFieldCountPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLFieldCountPacket {
    fn encode<'p, 'd>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_int_lenenc(this.column_count as usize);

        payload
    }
}

/**
 * Column definition above MySQL 4.1 packet protocol.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-query-response.html#packet-Protocol::ColumnDefinition41">ColumnDefinition41</a>
 * @see <a href="https://mariadb.com/kb/en/library/resultset/#column-definition-packet">Column definition packet</a>
 */
pub struct MySQLColumnDefinition41Packet {
    /// "def"
    catalog: String,
    /// 0x0c
    next_length: u8,
    sequence_id: u32,
    character_set: u16,
    flags: u16,
    schema: String,
    table: String,
    org_table: String,
    name: String,
    org_name: String,
    column_length: u32,
    /// MySQLColumnType
    column_type: u8,
    decimals: u8,
}

impl MySQLColumnDefinition41Packet {
    pub fn new(sequence_id: u32,
               character_set: u16,
               flags: u16,
               schema: String,
               table: String,
               org_table: String,
               name: String,
               org_name: String,
               column_length: u32,
               column_type: u8, // MySQLColumnType
               decimals: u8) -> Self {
        MySQLColumnDefinition41Packet {
            catalog: "def".to_string(),
            next_length: 0x0c,
            sequence_id,
            character_set,
            flags,
            schema,
            table,
            org_table,
            name,
            org_name,
            column_length,
            column_type,
            decimals,
        }
    }
}

impl MySQLPacket for MySQLColumnDefinition41Packet {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLColumnDefinition41Packet {
    fn encode<'p, 'd>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_string_lenenc(this.catalog.as_bytes());
        payload.put_string_lenenc(this.schema.as_bytes());
        payload.put_string_lenenc(this.table.as_bytes());
        payload.put_string_lenenc(this.org_table.as_bytes());
        payload.put_string_lenenc(this.name.as_bytes());
        payload.put_string_lenenc(this.org_name.as_bytes());
        payload.put_int_lenenc(this.next_length as usize);
        payload.put_u16_le(this.character_set);
        payload.put_u32_le(this.column_length);
        payload.put_u8(this.column_type as u8);
        payload.put_u16_le(this.flags);
        payload.put_u8(this.decimals);
        // Write null for reserved to byte buffers.
        let reserved: [u8; 2] = [0, 0];
        payload.put_slice(&reserved);

        payload
    }
}

/**
 * COM_INIT_DB command packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-init-db.html#packet-COM_INIT_DB">COM_INIT_DB</a>
 */
pub struct MySQLComInitDbPacket {
    sequence_id: u32,
    /// MySQLCommandPacketType,
    command_type: u8,
    schema: Vec<u8>,
}

impl MySQLComInitDbPacket {
    pub fn new(command_type: u8) -> Self {
        MySQLComInitDbPacket {
            sequence_id: 0,
            command_type: command_type, // MySQLCommandPacketType::value_of(command_type & 0xff),
            schema: vec![],
        }
    }

    pub fn get_schema(&self) -> Vec<u8> {
        self.schema.clone()
    }

    pub fn get_command_type(&self) -> u8 {
        self.command_type
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLComInitDbPacket {
    fn decode<'p, 'd>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload, session_ctx: &mut SessionContext) -> &'d mut Self {
        let bytes = payload.get_remaining_bytes();
        this.schema = Vec::from(bytes.as_slice());
        this
    }
}

impl MySQLPacket for MySQLComInitDbPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * COM_FIELD_LIST command packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-field-list.html">COM_FIELD_LIST</a>
 */
pub struct MySQLComFieldListPacket {
    sequence_id: u32,
    /// MySQLCommandPacketType,
    command_type: u8,
    table: Vec<u8>,
    field_wildcard: Vec<u8>,
}

impl MySQLComFieldListPacket {
    pub fn new(command_type: u8) -> Self {
        MySQLComFieldListPacket {
            sequence_id: 0,
            command_type: command_type, // MySQLCommandPacketType::value_of(command_type & 0xff),
            table: vec![],
            field_wildcard: vec![],
        }
    }

    pub fn get_table(&self) -> Vec<u8> {
        self.table.clone()
    }

    pub fn get_field_wildcard(&self) -> Vec<u8> {
        self.field_wildcard.clone()
    }

    pub fn get_command_type(&self) -> u8 {
        self.command_type
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload, SessionContext> for MySQLComFieldListPacket {
    fn decode<'p, 'd>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload, session_ctx: &mut SessionContext) -> &'d mut Self {
        this.table = payload.get_string_nul().into_bytes();
        let bytes = payload.get_remaining_bytes();
        this.field_wildcard = Vec::from(bytes.as_slice());
        this
    }
}

impl MySQLPacket for MySQLComFieldListPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}